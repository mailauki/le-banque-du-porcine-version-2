"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableEdgeInNextConfig = exports.writeEdgeFunctions = exports.writeDevEdgeFunction = exports.cleanupEdgeFunctions = exports.loadMiddlewareManifest = void 0;
/* eslint-disable max-lines */
const fs_1 = require("fs");
const path_1 = require("path");
const chalk_1 = require("chalk");
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const config_1 = require("./config");
const loadMiddlewareManifest = (netlifyConfig) => {
    const middlewarePath = (0, path_1.resolve)(netlifyConfig.build.publish, 'server', 'middleware-manifest.json');
    if (!(0, fs_1.existsSync)(middlewarePath)) {
        return null;
    }
    return (0, fs_extra_1.readJson)(middlewarePath);
};
exports.loadMiddlewareManifest = loadMiddlewareManifest;
/**
 * Convert the Next middleware name into a valid Edge Function name
 */
const sanitizeName = (name) => `next_${name.replace(/\W/g, '_')}`;
/**
 * Initialization added to the top of the edge function bundle
 */
const bootstrap = /* js */ `
globalThis.process = { env: {...Deno.env.toObject(), NEXT_RUNTIME: 'edge', 'NEXT_PRIVATE_MINIMAL_MODE': '1' } }
globalThis._ENTRIES ||= {}
// Deno defines "window", but naughty libraries think this means it's a browser
delete globalThis.window

`;
/**
 * Concatenates the Next edge function code with the required chunks and adds an export
 */
const getMiddlewareBundle = async ({ edgeFunctionDefinition, netlifyConfig, }) => {
    const { publish } = netlifyConfig.build;
    const chunks = [bootstrap];
    for (const file of edgeFunctionDefinition.files) {
        const filePath = (0, path_1.join)(publish, file);
        const data = await fs_1.promises.readFile(filePath, 'utf8');
        chunks.push('{', data, '}');
    }
    const middleware = await fs_1.promises.readFile((0, path_1.join)(publish, `server`, `${edgeFunctionDefinition.name}.js`), 'utf8');
    chunks.push(middleware);
    const exports = /* js */ `export default _ENTRIES["middleware_${edgeFunctionDefinition.name}"].default;`;
    chunks.push(exports);
    return chunks.join('\n');
};
const getEdgeTemplatePath = (file) => (0, path_1.join)(__dirname, '..', '..', 'src', 'templates', 'edge', file);
const copyEdgeSourceFile = ({ file, target, edgeFunctionDir, }) => fs_1.promises.copyFile(getEdgeTemplatePath(file), (0, path_1.join)(edgeFunctionDir, target !== null && target !== void 0 ? target : file));
const writeEdgeFunction = async ({ edgeFunctionDefinition, edgeFunctionRoot, netlifyConfig, }) => {
    const name = sanitizeName(edgeFunctionDefinition.name);
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, name);
    const bundle = await getMiddlewareBundle({
        edgeFunctionDefinition,
        netlifyConfig,
    });
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await fs_1.promises.writeFile((0, path_1.join)(edgeFunctionDir, 'bundle.js'), bundle);
    await copyEdgeSourceFile({
        edgeFunctionDir,
        file: 'runtime.ts',
        target: 'index.ts',
    });
    const matchers = [];
    // The v1 middleware manifest has a single regexp, but the v2 has an array of matchers
    if ('regexp' in edgeFunctionDefinition) {
        matchers.push({ regexp: edgeFunctionDefinition.regexp });
    }
    else {
        matchers.push(...edgeFunctionDefinition.matchers);
    }
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionDir, 'matchers.json'), matchers);
    // We add a defintion for each matching path
    return matchers.map((matcher) => {
        const pattern = matcher.regexp;
        return { function: name, pattern };
    });
};
const cleanupEdgeFunctions = ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => (0, fs_extra_1.emptyDir)(INTERNAL_EDGE_FUNCTIONS_SRC);
exports.cleanupEdgeFunctions = cleanupEdgeFunctions;
const writeDevEdgeFunction = async ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => {
    const manifest = {
        functions: [
            {
                function: 'next-dev',
                path: '/*',
            },
        ],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)(INTERNAL_EDGE_FUNCTIONS_SRC);
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'next-dev');
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await copyEdgeSourceFile({ edgeFunctionDir, file: 'next-dev.js', target: 'index.js' });
};
exports.writeDevEdgeFunction = writeDevEdgeFunction;
/**
 * Writes Edge Functions for the Next middleware
 */
const writeEdgeFunctions = async (netlifyConfig) => {
    const manifest = {
        functions: [],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)('.netlify', 'edge-functions');
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    const { publish } = netlifyConfig.build;
    const nextConfigFile = await (0, config_1.getRequiredServerFiles)(publish);
    const nextConfig = nextConfigFile.config;
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    await (0, fs_extra_1.writeJSON)((0, path_1.join)(edgeFunctionRoot, 'edge-shared', 'nextConfig.json'), nextConfig);
    if (!(0, destr_1.default)(process.env.NEXT_DISABLE_EDGE_IMAGES) &&
        !(0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE) &&
        !(0, destr_1.default)(process.env.DISABLE_IPX)) {
        console.log('Using Netlify Edge Functions for image format detection. Set env var "NEXT_DISABLE_EDGE_IMAGES=true" to disable.');
        const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'ipx');
        await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
        await copyEdgeSourceFile({ edgeFunctionDir, file: 'ipx.ts', target: 'index.ts' });
        await (0, fs_extra_1.copyFile)((0, path_1.join)('.netlify', 'functions-internal', '_ipx', 'imageconfig.json'), (0, path_1.join)(edgeFunctionDir, 'imageconfig.json'));
        manifest.functions.push({
            function: 'ipx',
            path: '/_next/image*',
        });
    }
    if (!(0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE)) {
        const middlewareManifest = await (0, exports.loadMiddlewareManifest)(netlifyConfig);
        if (!middlewareManifest) {
            console.error("Couldn't find the middleware manifest");
            return;
        }
        let usesEdge = false;
        for (const middleware of middlewareManifest.sortedMiddleware) {
            usesEdge = true;
            const edgeFunctionDefinition = middlewareManifest.middleware[middleware];
            const functionDefinitions = await writeEdgeFunction({
                edgeFunctionDefinition,
                edgeFunctionRoot,
                netlifyConfig,
            });
            manifest.functions.push(...functionDefinitions);
        }
        // Older versions of the manifest format don't have the functions field
        // No, the version field was not incremented
        if (typeof middlewareManifest.functions === 'object') {
            for (const edgeFunctionDefinition of Object.values(middlewareManifest.functions)) {
                usesEdge = true;
                const functionDefinitions = await writeEdgeFunction({
                    edgeFunctionDefinition,
                    edgeFunctionRoot,
                    netlifyConfig,
                });
                manifest.functions.push(...functionDefinitions);
            }
        }
        if (usesEdge) {
            console.log((0, outdent_1.outdent) `
        ✨ Deploying middleware and functions to ${(0, chalk_1.greenBright) `Netlify Edge Functions`} ✨
        This feature is in beta. Please share your feedback here: https://ntl.fyi/next-netlify-edge
      `);
        }
    }
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
};
exports.writeEdgeFunctions = writeEdgeFunctions;
const enableEdgeInNextConfig = async (publish) => {
    const configFile = (0, path_1.join)(publish, 'required-server-files.json');
    const config = await (0, fs_extra_1.readJSON)(configFile);
    await (0, fs_extra_1.writeJSON)(configFile, config);
};
exports.enableEdgeInNextConfig = enableEdgeInNextConfig;
/* eslint-enable max-lines */
